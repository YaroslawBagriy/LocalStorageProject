/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Injectable, Optional, Inject } from '@angular/core';
import { ReplaySubject, fromEvent, of, throwError, race } from 'rxjs';
import { map, mergeMap, first, tap } from 'rxjs/operators';
import { LocalStorageDatabase } from './localstorage-database';
import { LOCAL_STORAGE_PREFIX } from '../tokens';
import * as i0 from "@angular/core";
import * as i1 from "../tokens";
var IndexedDBDatabase = /** @class */ (function () {
    /**
     * Connects to IndexedDB
     */
    function IndexedDBDatabase(prefix) {
        if (prefix === void 0) { prefix = null; }
        this.prefix = prefix;
        /**
         * IndexedDB database name for local storage
         */
        this.dbName = 'ngStorage';
        /**
         * IndexedDB object store name for local storage
         */
        this.objectStoreName = 'localStorage';
        /**
         * IndexedDB key path name for local storage (where an item's key will be stored)
         */
        this.keyPath = 'key';
        /**
         * IndexedDB data path name for local storage (where items' value will be stored)
         */
        this.dataPath = 'value';
        /**
         * IndexedDB is available but failing in some scenarios (Firefox private mode, Safari cross-origin iframes),
         * so a fallback can be needed.
         */
        this.fallback = null;
        if (prefix) {
            this.dbName = prefix + "_" + this.dbName;
        }
        /* Creating the RxJS ReplaySubject */
        this.database = new ReplaySubject();
        /* Connecting to IndexedDB */
        this.connect(prefix);
    }
    /**
     * Gets an item value in local storage
     * @param key The item's key
     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.getItem = /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key) {
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.getItem(key);
        }
        /* Opening a trasaction and requesting the item in local storage */
        return this.getItemFromTransaction(key);
    };
    /**
     * Internal method to factorize the getter for getItem and setItem,
     * the last one needing to be from a preexisting transaction
     * @param key The item's key
     * @param transactionParam Optional pre-existing transaction to use for the read request
     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    /**
     * Internal method to factorize the getter for getItem and setItem,
     * the last one needing to be from a preexisting transaction
     * @template T
     * @param {?} key The item's key
     * @param {?=} transactionParam Optional pre-existing transaction to use for the read request
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.getItemFromTransaction = /**
     * Internal method to factorize the getter for getItem and setItem,
     * the last one needing to be from a preexisting transaction
     * @template T
     * @param {?} key The item's key
     * @param {?=} transactionParam Optional pre-existing transaction to use for the read request
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key, transactionParam) {
        var _this = this;
        /** @type {?} */
        var transaction$ = transactionParam ? of(transactionParam) : this.transaction();
        return transaction$.pipe(map(function (transaction) { return transaction.get(key); }), mergeMap(function (request) {
            /* Listening to the success event, and passing the item value if found, null otherwise */
            /** @type {?} */
            var success = ((/** @type {?} */ (fromEvent(request, 'success')))).pipe(map(function (event) { return ((/** @type {?} */ (event.target))).result; }), map(function (result) { return result && (_this.dataPath in result) ? ((/** @type {?} */ (result[_this.dataPath]))) : null; }));
            /* Merging success and errors events and autoclosing the observable */
            return ((/** @type {?} */ (race(success, _this.toErrorObservable(request, "getter")))))
                .pipe(first());
        }), first());
    };
    /**
     * Sets an item in local storage
     * @param key The item's key
     * @param data The item's value, must NOT be null or undefined
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.setItem = /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key, data) {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.setItem(key, data);
        }
        /* Storing null is not correctly supported by IndexedDB and unnecessary here */
        if (data == null) {
            return of(true);
        }
        /* Transaction must be the same for read and write, to avoid concurrency issues */
        /** @type {?} */
        var transaction$ = this.transaction('readwrite');
        /** @type {?} */
        var transaction;
        /* Opening a transaction */
        return transaction$.pipe(tap(function (value) {
            transaction = value;
        }), 
        /* Check if the key already exists or not */
        mergeMap(function () { return _this.getItemFromTransaction(key, transaction); }), map(function (existingData) { return (existingData == null) ? 'add' : 'put'; }), mergeMap(function (method) {
            var _a, _b;
            /** @type {?} */
            var request;
            /* Adding or updating local storage, based on previous checking */
            switch (method) {
                case 'add':
                    request = transaction.add((_a = {}, _a[_this.dataPath] = data, _a), key);
                    break;
                case 'put':
                default:
                    request = transaction.put((_b = {}, _b[_this.dataPath] = data, _b), key);
                    break;
            }
            /* Merging success (passing true) and error events and autoclosing the observable */
            return ((/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "setter")))))
                .pipe(first());
        }), first());
    };
    /**
     * Deletes an item in local storage
     * @param key The item's key
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.removeItem = /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key) {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.removeItem(key);
        }
        /* Opening a transaction and checking if the item exists in local storage */
        return this.getItem(key).pipe(mergeMap(function (data) {
            /* If the item exists in local storage */
            if (data != null) {
                /* Opening a transaction */
                return _this.transaction('readwrite').pipe(mergeMap(function (transaction) {
                    /* Deleting the item in local storage */
                    /** @type {?} */
                    var request = transaction.delete(key);
                    /* Merging success (passing true) and error events and autoclosing the observable */
                    return ((/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "remover")))))
                        .pipe(first());
                }));
            }
            /* Passing true if the item does not exist in local storage */
            return of(true);
        }), first());
    };
    /**
     * Deletes all items from local storage
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.clear = /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function () {
        var _this = this;
        /* Fallback storage if set */
        if (this.fallback) {
            return this.fallback.clear();
        }
        /* Opening a transaction */
        return this.transaction('readwrite').pipe(mergeMap(function (transaction) {
            /* Deleting all items from local storage */
            /** @type {?} */
            var request = transaction.clear();
            /* Merging success (passing true) and error events and autoclosing the observable */
            return ((/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "clearer")))))
                .pipe(first());
        }), first());
    };
    /**
     * Connects to IndexedDB and creates the object store on first time
     */
    /**
     * Connects to IndexedDB and creates the object store on first time
     * @param {?=} prefix
     * @return {?}
     */
    IndexedDBDatabase.prototype.connect = /**
     * Connects to IndexedDB and creates the object store on first time
     * @param {?=} prefix
     * @return {?}
     */
    function (prefix) {
        var _this = this;
        if (prefix === void 0) { prefix = null; }
        /** @type {?} */
        var request;
        /* Connecting to IndexedDB */
        try {
            request = indexedDB.open(this.dbName);
        }
        catch (error) {
            /* Fallback storage if IndexedDb connection is failing */
            this.setFallback(prefix);
            return;
        }
        /* Listening the event fired on first connection, creating the object store for local storage */
        ((/** @type {?} */ (fromEvent(request, 'upgradeneeded'))))
            .pipe(first())
            .subscribe(function (event) {
            /* Getting the database connection */
            /** @type {?} */
            var database = (/** @type {?} */ (((/** @type {?} */ (event.target))).result));
            /* Checking if the object store already exists, to avoid error */
            if (!database.objectStoreNames.contains(_this.objectStoreName)) {
                /* Creating the object store for local storage */
                database.createObjectStore(_this.objectStoreName);
            }
        });
        /* Listening the success event and converting to an RxJS Observable */
        /** @type {?} */
        var success = (/** @type {?} */ (fromEvent(request, 'success')));
        /* Merging success and errors events */
        ((/** @type {?} */ (race(success, this.toErrorObservable(request, "connection")))))
            .pipe(first())
            .subscribe(function (event) {
            /* Storing the database connection for further access */
            _this.database.next((/** @type {?} */ (((/** @type {?} */ (event.target))).result)));
        }, function () {
            /* Fallback storage if IndexedDb connection is failing */
            _this.setFallback(prefix);
        });
    };
    /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @returns An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.transaction = /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    function (mode) {
        var _this = this;
        if (mode === void 0) { mode = 'readonly'; }
        /* From the IndexedDB connection, opening a transaction and getting the local storage objet store */
        return this.database
            .pipe(map(function (database) { return database.transaction([_this.objectStoreName], mode).objectStore(_this.objectStoreName); }));
    };
    /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param request The request to listen
     * @returns A RxJS Observable with true value
     */
    /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param {?} request The request to listen
     * @return {?} A RxJS Observable with true value
     */
    IndexedDBDatabase.prototype.toSuccessObservable = /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param {?} request The request to listen
     * @return {?} A RxJS Observable with true value
     */
    function (request) {
        /* Transforming a IndexedDB success event in an RxJS Observable with true value */
        return ((/** @type {?} */ (fromEvent(request, 'success'))))
            .pipe(map(function () { return true; }));
    };
    /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param request The request to listen
     * @param error Optionnal details about the error's origin
     * @returns A RxJS ErrorObservable
     */
    /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param {?} request The request to listen
     * @param {?=} error Optionnal details about the error's origin
     * @return {?} A RxJS ErrorObservable
     */
    IndexedDBDatabase.prototype.toErrorObservable = /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param {?} request The request to listen
     * @param {?=} error Optionnal details about the error's origin
     * @return {?} A RxJS ErrorObservable
     */
    function (request, error) {
        if (error === void 0) { error = ""; }
        /* Transforming a IndexedDB error event in an RxJS ErrorObservable */
        return ((/** @type {?} */ (fromEvent(request, 'error'))))
            .pipe(mergeMap(function () { return throwError(new Error("IndexedDB " + error + " issue : " + ((/** @type {?} */ (request.error))).message + ".")); }));
    };
    /**
     * @param {?} prefix
     * @return {?}
     */
    IndexedDBDatabase.prototype.setFallback = /**
     * @param {?} prefix
     * @return {?}
     */
    function (prefix) {
        this.fallback = new LocalStorageDatabase(prefix);
    };
    IndexedDBDatabase.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    IndexedDBDatabase.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LOCAL_STORAGE_PREFIX,] }] }
    ]; };
    /** @nocollapse */ IndexedDBDatabase.ngInjectableDef = i0.defineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(i0.inject(i1.LOCAL_STORAGE_PREFIX, 8)); }, token: IndexedDBDatabase, providedIn: "root" });
    return IndexedDBDatabase;
}());
export { IndexedDBDatabase };
if (false) {
    /**
     * IndexedDB database name for local storage
     * @type {?}
     */
    IndexedDBDatabase.prototype.dbName;
    /**
     * IndexedDB object store name for local storage
     * @type {?}
     */
    IndexedDBDatabase.prototype.objectStoreName;
    /**
     * IndexedDB key path name for local storage (where an item's key will be stored)
     * @type {?}
     */
    IndexedDBDatabase.prototype.keyPath;
    /**
     * IndexedDB data path name for local storage (where items' value will be stored)
     * @type {?}
     */
    IndexedDBDatabase.prototype.dataPath;
    /**
     * IndexedDB database connection, wrapped in a RxJS ReplaySubject to be able to access the connection
     * even after the connection success event happened
     * @type {?}
     */
    IndexedDBDatabase.prototype.database;
    /**
     * IndexedDB is available but failing in some scenarios (Firefox private mode, Safari cross-origin iframes),
     * so a fallback can be needed.
     * @type {?}
     */
    IndexedDBDatabase.prototype.fallback;
    /** @type {?} */
    IndexedDBDatabase.prototype.prefix;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXhlZGRiLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1wd2EvbG9jYWwtc3RvcmFnZS8iLCJzb3VyY2VzIjpbImxpYi9kYXRhYmFzZXMvaW5kZXhlZGRiLWRhdGFiYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFjLGFBQWEsRUFBRSxTQUFTLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEYsT0FBTyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRzNELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQy9ELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7O0FBRWpEO0lBZ0NFOztPQUVHO0lBQ0gsMkJBQWdFLE1BQTRCO1FBQTVCLHVCQUFBLEVBQUEsYUFBNEI7UUFBNUIsV0FBTSxHQUFOLE1BQU0sQ0FBc0I7Ozs7UUEzQmxGLFdBQU0sR0FBRyxXQUFXLENBQUM7Ozs7UUFJWixvQkFBZSxHQUFHLGNBQWMsQ0FBQzs7OztRQUlqQyxZQUFPLEdBQUcsS0FBSyxDQUFDOzs7O1FBSWhCLGFBQVEsR0FBRyxPQUFPLENBQUM7Ozs7O1FBVTVCLGFBQVEsR0FBeUIsSUFBSSxDQUFDO1FBTzlDLElBQUksTUFBTSxFQUFFO1lBRVYsSUFBSSxDQUFDLE1BQU0sR0FBTSxNQUFNLFNBQUksSUFBSSxDQUFDLE1BQVEsQ0FBQztTQUUxQztRQUVELHFDQUFxQztRQUNyQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksYUFBYSxFQUFlLENBQUM7UUFFakQsNkJBQTZCO1FBQzdCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7SUFF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QWEsS0FBSyxpQkFBWSxDQUFDLG1CQUFBLE9BQU8sQ0FBQyxLQUFLLEVBQWdCLENBQUMsQ0FBQyxPQUFPLE1BQUcsQ0FBQyxDQUFDLEVBQS9GLENBQStGLENBQUMsQ0FBQyxDQUFDO0lBRTNILENBQUM7Ozs7O0lBRVMsdUNBQVc7Ozs7SUFBckIsVUFBc0IsTUFBcUI7UUFDekMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25ELENBQUM7O2dCQXRVRixVQUFVLFNBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzs7O2dEQWlDYyxRQUFRLFlBQUksTUFBTSxTQUFDLG9CQUFvQjs7OzRCQTNDdEQ7Q0FnVkMsQUF4VUQsSUF3VUM7U0FyVVksaUJBQWlCOzs7Ozs7SUFLNUIsbUNBQStCOzs7OztJQUkvQiw0Q0FBb0Q7Ozs7O0lBSXBELG9DQUFtQzs7Ozs7SUFJbkMscUNBQXNDOzs7Ozs7SUFLdEMscUNBQStDOzs7Ozs7SUFLL0MscUNBQWdEOztJQUtwQyxtQ0FBZ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0LCBmcm9tRXZlbnQsIG9mLCB0aHJvd0Vycm9yLCByYWNlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIG1lcmdlTWFwLCBmaXJzdCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBMb2NhbERhdGFiYXNlIH0gZnJvbSAnLi9sb2NhbC1kYXRhYmFzZSc7XG5pbXBvcnQgeyBMb2NhbFN0b3JhZ2VEYXRhYmFzZSB9IGZyb20gJy4vbG9jYWxzdG9yYWdlLWRhdGFiYXNlJztcbmltcG9ydCB7IExPQ0FMX1NUT1JBR0VfUFJFRklYIH0gZnJvbSAnLi4vdG9rZW5zJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgSW5kZXhlZERCRGF0YWJhc2UgaW1wbGVtZW50cyBMb2NhbERhdGFiYXNlIHtcblxuICAvKipcbiAgICogSW5kZXhlZERCIGRhdGFiYXNlIG5hbWUgZm9yIGxvY2FsIHN0b3JhZ2VcbiAgICovXG4gIHByb3RlY3RlZCBkYk5hbWUgPSAnbmdTdG9yYWdlJztcbiAgLyoqXG4gICAqIEluZGV4ZWREQiBvYmplY3Qgc3RvcmUgbmFtZSBmb3IgbG9jYWwgc3RvcmFnZVxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IG9iamVjdFN0b3JlTmFtZSA9ICdsb2NhbFN0b3JhZ2UnO1xuICAvKipcbiAgICogSW5kZXhlZERCIGtleSBwYXRoIG5hbWUgZm9yIGxvY2FsIHN0b3JhZ2UgKHdoZXJlIGFuIGl0ZW0ncyBrZXkgd2lsbCBiZSBzdG9yZWQpXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkga2V5UGF0aCA9ICdrZXknO1xuICAvKipcbiAgICogSW5kZXhlZERCIGRhdGEgcGF0aCBuYW1lIGZvciBsb2NhbCBzdG9yYWdlICh3aGVyZSBpdGVtcycgdmFsdWUgd2lsbCBiZSBzdG9yZWQpXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGF0YVBhdGggPSAndmFsdWUnO1xuICAvKipcbiAgICogSW5kZXhlZERCIGRhdGFiYXNlIGNvbm5lY3Rpb24sIHdyYXBwZWQgaW4gYSBSeEpTIFJlcGxheVN1YmplY3QgdG8gYmUgYWJsZSB0byBhY2Nlc3MgdGhlIGNvbm5lY3Rpb25cbiAgICogZXZlbiBhZnRlciB0aGUgY29ubmVjdGlvbiBzdWNjZXNzIGV2ZW50IGhhcHBlbmVkXG4gICAqL1xuICBwcm90ZWN0ZWQgZGF0YWJhc2U6IFJlcGxheVN1YmplY3Q8SURCRGF0YWJhc2U+O1xuICAvKipcbiAgICogSW5kZXhlZERCIGlzIGF2YWlsYWJsZSBidXQgZmFpbGluZyBpbiBzb21lIHNjZW5hcmlvcyAoRmlyZWZveCBwcml2YXRlIG1vZGUsIFNhZmFyaSBjcm9zcy1vcmlnaW4gaWZyYW1lcyksXG4gICAqIHNvIGEgZmFsbGJhY2sgY2FuIGJlIG5lZWRlZC5cbiAgICovXG4gIHByb3RlY3RlZCBmYWxsYmFjazogTG9jYWxEYXRhYmFzZSB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byBJbmRleGVkREJcbiAgICovXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBJbmplY3QoTE9DQUxfU1RPUkFHRV9QUkVGSVgpIHByb3RlY3RlZCBwcmVmaXg6IHN0cmluZyB8IG51bGwgPSBudWxsKSB7XG5cbiAgICBpZiAocHJlZml4KSB7XG5cbiAgICAgIHRoaXMuZGJOYW1lID0gYCR7cHJlZml4fV8ke3RoaXMuZGJOYW1lfWA7XG5cbiAgICB9XG5cbiAgICAvKiBDcmVhdGluZyB0aGUgUnhKUyBSZXBsYXlTdWJqZWN0ICovXG4gICAgdGhpcy5kYXRhYmFzZSA9IG5ldyBSZXBsYXlTdWJqZWN0PElEQkRhdGFiYXNlPigpO1xuXG4gICAgLyogQ29ubmVjdGluZyB0byBJbmRleGVkREIgKi9cbiAgICB0aGlzLmNvbm5lY3QocHJlZml4KTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gaXRlbSB2YWx1ZSBpbiBsb2NhbCBzdG9yYWdlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgVGhlIGl0ZW0ncyB2YWx1ZSBpZiB0aGUga2V5IGV4aXN0cywgbnVsbCBvdGhlcndpc2UsIHdyYXBwZWQgaW4gYW4gUnhKUyBPYnNlcnZhYmxlXG4gICAqL1xuICBnZXRJdGVtPFQgPSBhbnk+KGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUwqB8IG51bGw+IHtcblxuICAgIC8qIEZhbGxiYWNrIHN0b3JhZ2UgaWYgc2V0ICovXG4gICAgaWYgKHRoaXMuZmFsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLmZhbGxiYWNrLmdldEl0ZW08VD4oa2V5KTtcbiAgICB9XG5cbiAgICAvKiBPcGVuaW5nIGEgdHJhc2FjdGlvbiBhbmQgcmVxdWVzdGluZyB0aGUgaXRlbSBpbiBsb2NhbCBzdG9yYWdlICovXG4gICAgcmV0dXJuIHRoaXMuZ2V0SXRlbUZyb21UcmFuc2FjdGlvbjxUPihrZXkpO1xuXG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGZhY3Rvcml6ZSB0aGUgZ2V0dGVyIGZvciBnZXRJdGVtIGFuZCBzZXRJdGVtLFxuICAgKiB0aGUgbGFzdCBvbmUgbmVlZGluZyB0byBiZSBmcm9tIGEgcHJlZXhpc3RpbmcgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25QYXJhbSBPcHRpb25hbCBwcmUtZXhpc3RpbmcgdHJhbnNhY3Rpb24gdG8gdXNlIGZvciB0aGUgcmVhZCByZXF1ZXN0XG4gICAqIEByZXR1cm5zIFRoZSBpdGVtJ3MgdmFsdWUgaWYgdGhlIGtleSBleGlzdHMsIG51bGwgb3RoZXJ3aXNlLCB3cmFwcGVkIGluIGFuIFJ4SlMgT2JzZXJ2YWJsZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRJdGVtRnJvbVRyYW5zYWN0aW9uPFQgPSBhbnk+KGtleTogc3RyaW5nLCB0cmFuc2FjdGlvblBhcmFtPzogSURCT2JqZWN0U3RvcmUpOiBPYnNlcnZhYmxlPFTCoHwgbnVsbD4ge1xuXG4gICAgY29uc3QgdHJhbnNhY3Rpb24kID0gdHJhbnNhY3Rpb25QYXJhbSA/IG9mKHRyYW5zYWN0aW9uUGFyYW0pIDogdGhpcy50cmFuc2FjdGlvbigpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uJC5waXBlKFxuICAgICAgbWFwKCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uZ2V0KGtleSkpLFxuICAgICAgbWVyZ2VNYXAoKHJlcXVlc3QpID0+IHtcblxuICAgICAgICAvKiBMaXN0ZW5pbmcgdG8gdGhlIHN1Y2Nlc3MgZXZlbnQsIGFuZCBwYXNzaW5nIHRoZSBpdGVtIHZhbHVlIGlmIGZvdW5kLCBudWxsIG90aGVyd2lzZSAqL1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gKGZyb21FdmVudChyZXF1ZXN0LCAnc3VjY2VzcycpIGFzIE9ic2VydmFibGU8RXZlbnQ+KS5waXBlKFxuICAgICAgICAgIG1hcCgoZXZlbnQpID0+IChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdCkucmVzdWx0KSxcbiAgICAgICAgICBtYXAoKHJlc3VsdCkgPT4gcmVzdWx0ICYmICh0aGlzLmRhdGFQYXRoIGluIHJlc3VsdCkgPyAocmVzdWx0W3RoaXMuZGF0YVBhdGhdIGFzIFQpIDogbnVsbClcbiAgICAgICAgKTtcblxuICAgICAgICAvKiBNZXJnaW5nIHN1Y2Nlc3MgYW5kIGVycm9ycyBldmVudHMgYW5kIGF1dG9jbG9zaW5nIHRoZSBvYnNlcnZhYmxlICovXG4gICAgICAgIHJldHVybiAocmFjZShzdWNjZXNzLCB0aGlzLnRvRXJyb3JPYnNlcnZhYmxlKHJlcXVlc3QsIGBnZXR0ZXJgKSkgYXMgT2JzZXJ2YWJsZTxUIHwgbnVsbD4pXG4gICAgICAgICAgLnBpcGUoZmlyc3QoKSk7XG4gICAgICB9KSxcbiAgICAgIGZpcnN0KClcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBpdGVtIGluIGxvY2FsIHN0b3JhZ2VcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcGFyYW0gZGF0YSBUaGUgaXRlbSdzIHZhbHVlLCBtdXN0IE5PVCBiZSBudWxsIG9yIHVuZGVmaW5lZFxuICAgKiBAcmV0dXJucyBBbiBSeEpTIE9ic2VydmFibGUgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIHNldEl0ZW0oa2V5OiBzdHJpbmcsIGRhdGE6IGFueSk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgLyogRmFsbGJhY2sgc3RvcmFnZSBpZiBzZXQgKi9cbiAgICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2suc2V0SXRlbShrZXksIGRhdGEpO1xuICAgIH1cblxuICAgIC8qIFN0b3JpbmcgbnVsbCBpcyBub3QgY29ycmVjdGx5IHN1cHBvcnRlZCBieSBJbmRleGVkREIgYW5kIHVubmVjZXNzYXJ5IGhlcmUgKi9cbiAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG5cbiAgICAgIHJldHVybiBvZih0cnVlKTtcblxuICAgIH1cblxuICAgIC8qIFRyYW5zYWN0aW9uIG11c3QgYmUgdGhlIHNhbWUgZm9yIHJlYWQgYW5kIHdyaXRlLCB0byBhdm9pZCBjb25jdXJyZW5jeSBpc3N1ZXMgKi9cbiAgICBjb25zdCB0cmFuc2FjdGlvbiQgPSB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKTtcbiAgICBsZXQgdHJhbnNhY3Rpb246IElEQk9iamVjdFN0b3JlO1xuXG4gICAgICAgIC8qIE9wZW5pbmcgYSB0cmFuc2FjdGlvbiAqL1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb24kLnBpcGUoXG4gICAgICAgICAgdGFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB2YWx1ZTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvKiBDaGVjayBpZiB0aGUga2V5IGFscmVhZHkgZXhpc3RzIG9yIG5vdCAqL1xuICAgICAgICAgIG1lcmdlTWFwKCgpID0+IHRoaXMuZ2V0SXRlbUZyb21UcmFuc2FjdGlvbihrZXksIHRyYW5zYWN0aW9uKSksXG4gICAgICAgICAgbWFwKChleGlzdGluZ0RhdGEpID0+IChleGlzdGluZ0RhdGEgPT0gbnVsbCkgPyAnYWRkJyA6ICdwdXQnKSxcbiAgICAgICAgICBtZXJnZU1hcCgobWV0aG9kKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCByZXF1ZXN0OiBJREJSZXF1ZXN0O1xuXG4gICAgICAgICAgICAvKiBBZGRpbmcgb3IgdXBkYXRpbmcgbG9jYWwgc3RvcmFnZSwgYmFzZWQgb24gcHJldmlvdXMgY2hlY2tpbmcgKi9cbiAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHRyYW5zYWN0aW9uLmFkZCh7IFt0aGlzLmRhdGFQYXRoXTogZGF0YSB9LCBrZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdwdXQnOlxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5wdXQoeyBbdGhpcy5kYXRhUGF0aF06IGRhdGEgfSwga2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogTWVyZ2luZyBzdWNjZXNzIChwYXNzaW5nIHRydWUpIGFuZCBlcnJvciBldmVudHMgYW5kIGF1dG9jbG9zaW5nIHRoZSBvYnNlcnZhYmxlICovXG4gICAgICAgICAgICByZXR1cm4gKHJhY2UodGhpcy50b1N1Y2Nlc3NPYnNlcnZhYmxlKHJlcXVlc3QpLCB0aGlzLnRvRXJyb3JPYnNlcnZhYmxlKHJlcXVlc3QsIGBzZXR0ZXJgKSkgYXMgT2JzZXJ2YWJsZTxib29sZWFuPilcbiAgICAgICAgICAgICAgLnBpcGUoZmlyc3QoKSk7XG5cbiAgICAgICAgfSksXG4gICAgICAgIGZpcnN0KClcbiAgICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGl0ZW0gaW4gbG9jYWwgc3RvcmFnZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgT2JzZXJ2YWJsZSB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgLyogRmFsbGJhY2sgc3RvcmFnZSBpZiBzZXQgKi9cbiAgICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2sucmVtb3ZlSXRlbShrZXkpO1xuICAgIH1cblxuICAgIC8qIE9wZW5pbmcgYSB0cmFuc2FjdGlvbiBhbmQgY2hlY2tpbmcgaWYgdGhlIGl0ZW0gZXhpc3RzIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGtleSkucGlwZShcbiAgICAgIG1lcmdlTWFwKChkYXRhKSA9PiB7XG5cbiAgICAgICAgLyogSWYgdGhlIGl0ZW0gZXhpc3RzIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuXG4gICAgICAgICAgLyogT3BlbmluZyBhIHRyYW5zYWN0aW9uICovXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpLnBpcGUobWVyZ2VNYXAoKHRyYW5zYWN0aW9uKSA9PiB7XG5cbiAgICAgICAgICAgIC8qIERlbGV0aW5nIHRoZSBpdGVtIGluIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgLyogTWVyZ2luZyBzdWNjZXNzIChwYXNzaW5nIHRydWUpIGFuZCBlcnJvciBldmVudHMgYW5kIGF1dG9jbG9zaW5nIHRoZSBvYnNlcnZhYmxlICovXG4gICAgICAgICAgICByZXR1cm4gKHJhY2UodGhpcy50b1N1Y2Nlc3NPYnNlcnZhYmxlKHJlcXVlc3QpLCB0aGlzLnRvRXJyb3JPYnNlcnZhYmxlKHJlcXVlc3QsIGByZW1vdmVyYCkpIGFzIE9ic2VydmFibGU8Ym9vbGVhbj4pXG4gICAgICAgICAgICAgIC5waXBlKGZpcnN0KCkpO1xuXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvKiBQYXNzaW5nIHRydWUgaWYgdGhlIGl0ZW0gZG9lcyBub3QgZXhpc3QgaW4gbG9jYWwgc3RvcmFnZSAqL1xuICAgICAgICByZXR1cm4gb2YodHJ1ZSk7XG5cbiAgICAgIH0pLFxuICAgICAgZmlyc3QoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBpdGVtcyBmcm9tIGxvY2FsIHN0b3JhZ2VcbiAgICogQHJldHVybnMgQW4gUnhKUyBPYnNlcnZhYmxlIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBjbGVhcigpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblxuICAgIC8qIEZhbGxiYWNrIHN0b3JhZ2UgaWYgc2V0ICovXG4gICAgaWYgKHRoaXMuZmFsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLmZhbGxiYWNrLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLyogT3BlbmluZyBhIHRyYW5zYWN0aW9uICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgodHJhbnNhY3Rpb24pID0+IHtcblxuICAgICAgICAvKiBEZWxldGluZyBhbGwgaXRlbXMgZnJvbSBsb2NhbCBzdG9yYWdlICovXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0cmFuc2FjdGlvbi5jbGVhcigpO1xuXG4gICAgICAgIC8qIE1lcmdpbmcgc3VjY2VzcyAocGFzc2luZyB0cnVlKSBhbmQgZXJyb3IgZXZlbnRzIGFuZCBhdXRvY2xvc2luZyB0aGUgb2JzZXJ2YWJsZSAqL1xuICAgICAgICByZXR1cm4gKHJhY2UodGhpcy50b1N1Y2Nlc3NPYnNlcnZhYmxlKHJlcXVlc3QpLCB0aGlzLnRvRXJyb3JPYnNlcnZhYmxlKHJlcXVlc3QsIGBjbGVhcmVyYCkpIGFzIE9ic2VydmFibGU8Ym9vbGVhbj4pXG4gICAgICAgICAgLnBpcGUoZmlyc3QoKSk7XG5cbiAgICAgIH0pLFxuICAgICAgZmlyc3QoKVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byBJbmRleGVkREIgYW5kIGNyZWF0ZXMgdGhlIG9iamVjdCBzdG9yZSBvbiBmaXJzdCB0aW1lXG4gICAqL1xuICBwcm90ZWN0ZWQgY29ubmVjdChwcmVmaXg6IHN0cmluZyB8IG51bGwgPSBudWxsKTogdm9pZCB7XG5cbiAgICBsZXQgcmVxdWVzdDogSURCT3BlbkRCUmVxdWVzdDtcblxuICAgIC8qIENvbm5lY3RpbmcgdG8gSW5kZXhlZERCICovXG4gICAgdHJ5IHtcblxuICAgICAgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lKTtcblxuICAgIH3CoGNhdGNoIChlcnJvcikge1xuXG4gICAgICAvKiBGYWxsYmFjayBzdG9yYWdlIGlmIEluZGV4ZWREYiBjb25uZWN0aW9uIGlzIGZhaWxpbmcgKi9cbiAgICAgIHRoaXMuc2V0RmFsbGJhY2socHJlZml4KTtcblxuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgLyogTGlzdGVuaW5nIHRoZSBldmVudCBmaXJlZCBvbiBmaXJzdCBjb25uZWN0aW9uLCBjcmVhdGluZyB0aGUgb2JqZWN0IHN0b3JlIGZvciBsb2NhbCBzdG9yYWdlICovXG4gICAgKGZyb21FdmVudChyZXF1ZXN0LCAndXBncmFkZW5lZWRlZCcpIGFzIE9ic2VydmFibGU8RXZlbnQ+KVxuICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgIC5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG5cbiAgICAgICAgLyogR2V0dGluZyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiAqL1xuICAgICAgICBjb25zdCBkYXRhYmFzZSA9IChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdCkucmVzdWx0IGFzIElEQkRhdGFiYXNlO1xuXG4gICAgICAgIC8qIENoZWNraW5nIGlmIHRoZSBvYmplY3Qgc3RvcmUgYWxyZWFkeSBleGlzdHMsIHRvIGF2b2lkIGVycm9yICovXG4gICAgICAgIGlmICghZGF0YWJhc2Uub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyh0aGlzLm9iamVjdFN0b3JlTmFtZSkpIHtcblxuICAgICAgICAgIC8qIENyZWF0aW5nIHRoZSBvYmplY3Qgc3RvcmUgZm9yIGxvY2FsIHN0b3JhZ2UgKi9cbiAgICAgICAgICBkYXRhYmFzZS5jcmVhdGVPYmplY3RTdG9yZSh0aGlzLm9iamVjdFN0b3JlTmFtZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIC8qIExpc3RlbmluZyB0aGUgc3VjY2VzcyBldmVudCBhbmQgY29udmVydGluZyB0byBhbiBSeEpTIE9ic2VydmFibGUgKi9cbiAgICBjb25zdCBzdWNjZXNzID0gZnJvbUV2ZW50KHJlcXVlc3QsICdzdWNjZXNzJykgYXMgT2JzZXJ2YWJsZTxFdmVudD47XG5cbiAgICAvKiBNZXJnaW5nIHN1Y2Nlc3MgYW5kIGVycm9ycyBldmVudHMgKi9cbiAgICAocmFjZShzdWNjZXNzLCB0aGlzLnRvRXJyb3JPYnNlcnZhYmxlKHJlcXVlc3QsIGBjb25uZWN0aW9uYCkpIGFzIE9ic2VydmFibGU8RXZlbnQ+KVxuICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgIC5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG5cbiAgICAgICAgLyogU3RvcmluZyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiBmb3IgZnVydGhlciBhY2Nlc3MgKi9cbiAgICAgICAgdGhpcy5kYXRhYmFzZS5uZXh0KChldmVudC50YXJnZXQgYXMgSURCUmVxdWVzdCkucmVzdWx0IGFzIElEQkRhdGFiYXNlKTtcblxuICAgICAgfSwgKCkgPT4ge1xuXG4gICAgICAgIC8qIEZhbGxiYWNrIHN0b3JhZ2UgaWYgSW5kZXhlZERiIGNvbm5lY3Rpb24gaXMgZmFpbGluZyAqL1xuICAgICAgICB0aGlzLnNldEZhbGxiYWNrKHByZWZpeCk7XG5cbiAgICAgIH0pO1xuXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgYW4gSW5kZXhlZERCIHRyYW5zYWN0aW9uIGFuZCBnZXRzIHRoZSBsb2NhbCBzdG9yYWdlIG9iamVjdCBzdG9yZVxuICAgKiBAcGFyYW0gbW9kZSBEZWZhdWx0IHRvICdyZWFkb25seScgZm9yIHJlYWQgb3BlcmF0aW9ucywgb3IgJ3JlYWR3cml0ZScgZm9yIHdyaXRlIG9wZXJhdGlvbnNcbiAgICogQHJldHVybnMgQW4gSW5kZXhlZERCIHRyYW5zYWN0aW9uIG9iamVjdCBzdG9yZSwgd3JhcHBlZCBpbiBhbiBSeEpTIE9ic2VydmFibGVcbiAgICovXG4gIHByb3RlY3RlZCB0cmFuc2FjdGlvbihtb2RlOiAncmVhZG9ubHknIHwgJ3JlYWR3cml0ZScgPSAncmVhZG9ubHknKTogT2JzZXJ2YWJsZTxJREJPYmplY3RTdG9yZT4ge1xuXG4gICAgLyogRnJvbSB0aGUgSW5kZXhlZERCIGNvbm5lY3Rpb24sIG9wZW5pbmcgYSB0cmFuc2FjdGlvbiBhbmQgZ2V0dGluZyB0aGUgbG9jYWwgc3RvcmFnZSBvYmpldCBzdG9yZSAqL1xuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlXG4gICAgICAucGlwZShtYXAoKGRhdGFiYXNlKSA9PiBkYXRhYmFzZS50cmFuc2FjdGlvbihbdGhpcy5vYmplY3RTdG9yZU5hbWVdLCBtb2RlKS5vYmplY3RTdG9yZSh0aGlzLm9iamVjdFN0b3JlTmFtZSkpKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYSBJbmRleGVkREIgc3VjY2VzcyBldmVudCBpbiBhbiBSeEpTIE9ic2VydmFibGVcbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIHJlcXVlc3QgdG8gbGlzdGVuXG4gICAqIEByZXR1cm5zIEEgUnhKUyBPYnNlcnZhYmxlIHdpdGggdHJ1ZSB2YWx1ZVxuICAgKi9cbiAgcHJvdGVjdGVkIHRvU3VjY2Vzc09ic2VydmFibGUocmVxdWVzdDogSURCUmVxdWVzdCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgLyogVHJhbnNmb3JtaW5nIGEgSW5kZXhlZERCIHN1Y2Nlc3MgZXZlbnQgaW4gYW4gUnhKUyBPYnNlcnZhYmxlIHdpdGggdHJ1ZSB2YWx1ZSAqL1xuICAgIHJldHVybiAoZnJvbUV2ZW50KHJlcXVlc3QsICdzdWNjZXNzJykgYXMgT2JzZXJ2YWJsZTxFdmVudD4pXG4gICAgICAucGlwZShtYXAoKCkgPT4gdHJ1ZSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIEluZGV4ZWREQiBlcnJvciBldmVudCBpbiBhbiBSeEpTIEVycm9yT2JzZXJ2YWJsZVxuICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUgcmVxdWVzdCB0byBsaXN0ZW5cbiAgICogQHBhcmFtIGVycm9yIE9wdGlvbm5hbCBkZXRhaWxzIGFib3V0IHRoZSBlcnJvcidzIG9yaWdpblxuICAgKiBAcmV0dXJucyBBIFJ4SlMgRXJyb3JPYnNlcnZhYmxlXG4gICAqL1xuICBwcm90ZWN0ZWQgdG9FcnJvck9ic2VydmFibGUocmVxdWVzdDogSURCUmVxdWVzdCwgZXJyb3IgPSBgYCk6IE9ic2VydmFibGU8bmV2ZXI+IHtcblxuICAgIC8qIFRyYW5zZm9ybWluZyBhIEluZGV4ZWREQiBlcnJvciBldmVudCBpbiBhbiBSeEpTIEVycm9yT2JzZXJ2YWJsZSAqL1xuICAgIHJldHVybiAoZnJvbUV2ZW50KHJlcXVlc3QsICdlcnJvcicpIGFzIE9ic2VydmFibGU8RXZlbnQ+KVxuICAgICAgLnBpcGUobWVyZ2VNYXAoKCkgPT4gdGhyb3dFcnJvcihuZXcgRXJyb3IoYEluZGV4ZWREQiAke2Vycm9yfSBpc3N1ZSA6ICR7KHJlcXVlc3QuZXJyb3IgYXMgRE9NRXhjZXB0aW9uKS5tZXNzYWdlfS5gKSkpKTtcblxuICB9XG5cbiAgcHJvdGVjdGVkIHNldEZhbGxiYWNrKHByZWZpeDogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xuICAgIHRoaXMuZmFsbGJhY2sgPSBuZXcgTG9jYWxTdG9yYWdlRGF0YWJhc2UocHJlZml4KTtcbiAgfVxuXG59XG4iXX0=